import json
import time
import uuid
import random
from datetime import datetime, timedelta
import pytz
from geopy.geocoders import Nominatim
from meteostat import Point, Hourly

# Cargar puntos de venta válidos desde el archivo JSON
with open('valid_points.json', 'r') as file:
    points_of_sale = json.load(file)

# Generar 200 empleados, 2 por cada punto de venta
employees = {i: (f"Employee_{i*2+1}", f"Employee_{i*2+2}") for i in range(100)}

# Inicializar el geolocalizador
geolocator = Nominatim(user_agent="medellin_locator")

# Función para obtener la temperatura actual
def get_current_temperature(latitude, longitude):
    location = Point(latitude, longitude)
    start = datetime.now() - timedelta(hours=1)
    end = datetime.now()
    data = Hourly(location, start, end)
    data = data.fetch()
    temperature = data['temp'].mean() if not data.empty else 20  # Usar 20 como valor predeterminado si no hay datos
    return round(temperature, 1)

# Generar cantidad de productos en función de la temperatura
def generate_quantity_products(temperature):
    # Normalizar la temperatura entre un rango de 0 y 1
    temp_min, temp_max = 18, 24  # Rango de temperaturas en °C
    normalized_temp = (temperature - temp_min) / (temp_max - temp_min)
    
    # Generar la cantidad de productos basada en la temperatura normalizada
    min_quantity, max_quantity = 1, 50
    mean_quantity = normalized_temp * (max_quantity - min_quantity) + min_quantity
    
    # Añadir variabilidad a la cantidad de productos
    quantity = int(random.gauss(mean_quantity,10))  # Usar una desviación estándar de 10
    
    # Asegurar que la cantidad esté dentro del rango permitido
    return max(min(quantity, max_quantity), min_quantity)

# Generar datos simulados
def generate_event(pos_index):
    pos = points_of_sale[pos_index]
    worker = employees[pos_index]
    date_now = datetime.now(pytz.timezone('America/Bogota'))
    temperature = get_current_temperature(pos["latitude"], pos["longitude"])
    quantity_products = generate_quantity_products(temperature)
    
    event = {
        "latitude": pos["latitude"],
        "longitude": pos["longitude"],
        "date": date_now.strftime("%d/%m/%Y %H:%M:%S"),
        "customer_id": random.randint(1000, 2000),
        "employee_id": worker[0] if date_now.weekday() < 5 else worker[1],  # Lunes a Viernes / Fines de Semana
        "quantity_products": quantity_products,
        "order_id": str(uuid.uuid4()),
        "commune": pos["commune"],
        "neighborhood": pos["neighborhood"],
        "partition_date": date_now.strftime("%d%m%Y"),
        "event_date": date_now.strftime("%d/%m/%Y %H:%M:%S"),
        "event_day": date_now.day,
        "event_hour": date_now.hour,
        "event_minute": date_now.minute,
        "event_month": date_now.month,
        "event_second": date_now.second,
        "event_year": date_now.year,
        "current_temperature": temperature
    }
    return event

def main():
    for i in range(100):
        event = generate_event(i)
        # Aquí se puede guardar el evento en un archivo JSON, base de datos, etc.
        # Ejemplo de guardado en un archivo JSON
        with open('simulated_temp.json', 'a') as file:
            file.write(json.dumps(event) + "\n")
        # Esperar 1 segundo antes de generar el siguiente evento
        time.sleep(10)

if __name__ == "__main__":
    main()
