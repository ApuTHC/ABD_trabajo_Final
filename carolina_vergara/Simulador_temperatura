import json
import time
import uuid
import random
from datetime import datetime, timedelta
import pytz
from geopy.geocoders import Nominatim
from meteostat import Point, Hourly

# Definir las coordenadas aproximadas de Medellín
lat_range = (6.217, 6.317)  # Latitud de Medellín
lon_range = (-75.567, -75.467)  # Longitud de Medellín

# Inicializar el geolocalizador
geolocator = Nominatim(user_agent="medellin_locator")

# Función para obtener la comuna y barrio según las coordenadas
def get_location_info(latitude, longitude):
    location = geolocator.reverse((latitude, longitude), language='es')
    address = location.raw['address']
    comuna = address.get('suburb', 'No encontrado')
    barrio = address.get('neighbourhood', 'No encontrado')
    return comuna, barrio

# Generar puntos de venta únicos
def generate_valid_points(n):
    valid_points = []
    while len(valid_points) < n:
        lat = round(random.uniform(*lat_range), 6)
        lon = round(random.uniform(*lon_range), 6)
        comuna, barrio = get_location_info(lat, lon)
        if comuna != 'No encontrado' and barrio != 'No encontrado':
            valid_points.append((lat, lon, comuna, barrio))
    return valid_points

# Generar 100 puntos válidos
points_of_sale = generate_valid_points(100)

# Generar 200 empleados, 2 por cada punto de venta
employees = {i: (f"Employee_{i*2+1}", f"Employee_{i*2+2}") for i in range(100)}

# Función para obtener la temperatura actual
def get_current_temperature(latitude, longitude):
    location = Point(latitude, longitude)
    start = datetime.now() - timedelta(hours=1)
    end = datetime.now()
    data = Hourly(location, start, end)
    data = data.fetch()
    temperature = data['temp'].mean() if not data.empty else 20  # Usar 20 como valor predeterminado si no hay datos
    return round(temperature, 1)

# Generar cantidad de productos en función de la temperatura
def generate_quantity_products(temperature):
    # Normalizar la temperatura entre un rango de 0 y 1
    temp_min, temp_max = 18, 30  # Rango de temperaturas en °C
    normalized_temp = (temperature - temp_min) / (temp_max - temp_min)
    
    # Generar la cantidad de productos basada en la temperatura normalizada
    min_quantity, max_quantity = 1, 50
    quantity = int(normalized_temp * (max_quantity - min_quantity) + min_quantity)
    
    # Asegurar que la cantidad esté dentro del rango permitido
    return max(min(quantity, max_quantity), min_quantity)

# Generar datos simulados
def generate_event(pos_index):
    pos = points_of_sale[pos_index]
    worker = employees[pos_index]
    date_now = datetime.now(pytz.timezone('America/Bogota'))
    temperature = get_current_temperature(pos[0], pos[1])
    quantity_products = generate_quantity_products(temperature)
    
    event = {
        "latitude": pos[0],
        "longitude": pos[1],
        "date": date_now.strftime("%d/%m/%Y %H:%M:%S"),
        "customer_id": random.randint(1000, 2000),
        "employee_id": worker[0] if date_now.weekday() < 5 else worker[1],  # Lunes a Viernes / Fines de Semana
        "quantity_products": quantity_products,
        "order_id": str(uuid.uuid4()),
        "commune": pos[2],
        "neighborhood": pos[3],
        "partition_date": date_now.strftime("%d%m%Y"),
        "event_date": date_now.strftime("%d/%m/%Y %H:%M:%S"),
        "event_day": date_now.day,
        "event_hour": date_now.hour,
        "event_minute": date_now.minute,
        "event_month": date_now.month,
        "event_second": date_now.second,
        "event_year": date_now.year,
        "current_temperature": temperature
    }
    return event

def main():
    for i in range(100):
        event = generate_event(i)
        
        with open('simulated_data2.json', 'a') as file:
            file.write(json.dumps(event) + "\n")
        # Esperar 1 segundo antes de generar el siguiente evento
        time.sleep(1)

if __name__ == "__main__":
    main()
